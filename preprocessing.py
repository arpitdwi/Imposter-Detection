# -*- coding: utf-8 -*-
"""preprocess-fork-of-cv-fork-6-of-mies-t(5).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13lWNqWCDFNg7r1VdgFiOGgw3FQ9YpMXr
"""

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.model_selection import RandomizedSearchCV
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, f1_score, confusion_matrix
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.model_selection import RandomizedSearchCV, GridSearchCV
from datetime import datetime

import os
import gc
import random
import sys

from sklearn.preprocessing import MinMaxScaler

path = "mouse_data/"   # path + users[0] should be location of txt files for user 1
print(os.listdir(path))

#extractor function
# used to extract training data and testing from the collected data set

import numpy as np
import math
import os
#user=0 if imposter
#else 1
def features2(location,user=1):
    i = 1
    x = [0]; y = [0]
    same_xy = 0
    time_instant = []; dtime = []; s = []
    vx = []; vy = []; v = []; vdot = []; vdd = []
    theta_t = []; dtheta_t = [0]; theta = []
    c = []; delta_c = [0]; w = []; strokes = []    
    same_xy, time, MC_count, distance, path_length = 0, 0, 0, 0, 0

    for name in os.listdir(location):
        file = open(str(location+name), 'r')
        lines = file.readlines()
        startfrom = 7
        j = 0
        for line in lines:
            if j > 6:
                values = line.split(',')
                if values[0] == 'MM':
                    if int(values[3]) != 0:
                        if int(values[1]) != x[-1] or int(values[2]) != y[-1]:
                            x.append(int(values[1])), y.append(int(values[2]))
                            delay = int(values[3])
                            time += delay
                            time_instant.append(time)
                            if len(x) > 2:
                                a = x[-1] - x[-2]; b = y[-1] - y[-2]
                                distance = math.sqrt(pow(a,2)+pow(b,2))
                                s.append(distance)
                                if a == 0:
                                    theta_ti = math.pi/2
                                else:
                                    theta_ti = np.arctan(b/a)
                                path_length += distance
                                theta_t.append(theta_ti)
                                delta_t = time_instant[-1] - time_instant[-2]
                                vxi = a/delta_t; vyi = b/delta_t
                                vi = math.sqrt(pow(vxi,2)+pow(vyi,2))
                                vx.append(vxi); vy.append(vyi); v.append(vi)
                                theta_sum = find_theta_sum(dtheta_t)
                                thetai = theta_t[0] + theta_sum
                                theta.append(thetai)
                            if len(time_instant) > 1:
                                dtimei = time_instant[-1] - time_instant[-2]
                                dtime.append(dtimei)
                            if len(theta) > 1:
                                ci = (theta[-1] - theta[-2])/distance
                                wi = (theta[-1] - theta[-2])/delta_t
                                c.append(ci), w.append(wi)
                            if len(theta_t) > 1:
                                dtheta_ti = theta_t[-1] - theta_t[-2]
                                dtheta_ti = fit_theta(dtheta_ti)
                                dtheta_t.append(dtheta_ti)
                            if len(c) > 1:
                                delta_ci = c[-1] - c[-2]
                                delta_c.append(delta_ci)
                            if len(v) > 1:
                                dv = v[-1] - v[-2]
                                vdoti = dv/delta_t
                                vdot.append(vdoti)
                            if len(vdot) > 1:
                                dvdot = vdot[-1] - vdot[-2]
                                vddi = dvdot/delta_t
                                vdd.append(vddi)
                            #print(x, y, time_instant, vxi, vyi, vi, vdoti, vddi, distance, theta_ti)
                if values[0] == 'MC':
                    MC_count += 1
                if MC_count == 1:
                    x = [0]; y = [0]; time_instant = []; vx = []; vy = []; v = []; vdot = []
                    vdd = []; theta_t = []; dtheta_t = [0]; theta = []; c = []; delta_c = [0]; w = [] 
                    
                if values[0] == 'MC' and len(vdd) > 2 and MC_count != 1:
                    
                    stats = []
                    quants = [x, y, vx, vy, v, vdot, vdd, theta, w]
                    delay = int(values[2])
                    time += delay

                    for q in quants:
                        q = q[1:]
                        stat = []
                        stat.append(np.mean(q))
                        stat.append(np.std(q))
                        stat.append(min(q))
                        stat.append(max(q))
                        stat.append(max(q) - min(q))
                        stats.append(stat)
                    
                    critical_count = 0
                    for index, value in enumerate(delta_c):
                        if value == 0 or abs(c[index]) > math.pi/10:
                            critical_count += 1
                    t = time - time_instant[0]
                    l = path_length
                    click_time = time - time_instant[-1]
                    pause_count = 0
                    for value in dtime:
                        if value > 100:
                            pause_count += 1
                    total_pause_time = sum(dtime)
                    pause_time_ratio = total_pause_time/t
                    label = user
                        
                    #clear_stuff(x, y, time_instant, vx, vy, v, vdot, vdd, theta_t, dtheta_t, theta, c, delta_c, w)
                    x = [0]; y = [0]; time_instant = []; vx = []; vy = []; v = []; vdot = []
                    vdd = []; theta_t = []; dtheta_t = [0]; theta = []; c = []; delta_c = [0]; w = [] 
                    
                    path_length = 0
                    
                    stroke = []
                    for stat in stats:
                        for sx in stat:
                            stroke.append(sx)

                    stroke_suf = [t, l, critical_count, click_time, pause_count,
                              total_pause_time, pause_time_ratio, label]
                    
                    for qt in stroke_suf:
                        stroke.append(qt)
                    
                    strokes.append(stroke)
                    #print(stroke)
            j += 1
        #print('File Completed - ' + str(i))
        i += 1

    feature = np.array(strokes)
    
    return feature

   
def find_theta_sum(dtheta_t):
    theta_sum = 0
    for dtheta in dtheta_t:
        theta_sum += dtheta
    return theta_sum

def fit_theta(dtheta):
    if not (-(math.pi) < dtheta < math.pi):
        if dtheta < -(math.pi):
            p = 1
            while not -(math.pi) < dtheta:
                term = 2 * p * math.pi
                dtheta = dtheta + term
                p += 1
        if dtheta > math.pi:
            q = 1
            while not dtheta > math.pi:
                term = 2 * -1 * q * math.pi
                dtheta = dtheta + term
                q += 1
    return dtheta

users = os.listdir(path)
for i, user in enumerate(users):
    user_path = os.path.join(path, user) + "/"
    print(i, user_path)
    data_user = features2(location = user_path ,user=i)
    if i == 0:
        data = data_user
    else:
        data = np.concatenate([data, data_user], axis=0)

labels = data[:, -1].astype(int)
data = data[:, :-1]

print(np.unique(labels))

# try:
#     arpit_data = np.load(npy_path+"arpit_data.npy")
#     rushi_data = np.load(npy_path + "rushi_data.npy")
#     ravi_data = np.load(npy_path + "ravi_data.npy")
#     pankaj_data = np.load(npy_path + "pankaj_data.npy")
#     try: 
#         shubham_data = np.load(npy_path + "shubham_data (1).npy")
#     except:
#         shubham_data = np.load(npy_path + "shubham_data.npy")
# except:
#     print("please inpur correct files paths")


# l = [rushi_data, ravi_data, pankaj_data, shubham_data]
# data = arpit_data
# labels = np.array([0] * len(arpit_data))
# for x, i in enumerate(l):
#     data = np.concatenate([data, i], axis=0)
#     lab = np.array([x+1] * len(i))
#     labels = np.concatenate([labels, lab], axis=0)
    
# data.shape

sc = MinMaxScaler()
data = sc.fit_transform(data)

# taking user1 as crewmate and collection of equal data for crewmate and imposter

x = np.min(pd.Series(labels).value_counts())
y = x // 4


data_1 = data[np.where(labels == 0), :][0][:x, :]
print(data_1.shape)
data_2 = data[np.where(labels == 1), :][0][:y, :]
print(data_2.shape)
data_3 = data[np.where(labels == 2), :][0][:y, :]
print(data_3.shape)
data_4 = data[np.where(labels == 3), :][0][:y, :]
print(data_4.shape)
data_5 = data[np.where(labels == 4), :][0][:y, :]
print(data_5.shape)

l = [data_1, data_2, data_3, data_4, data_5]
data = l[0]
for i in l[1:]:
    data = np.concatenate([data, i], axis=0)
print(data.shape)
labels_1 = labels[np.where(labels == 0)][:x]
print(labels_1.shape)
labels_2 = labels[np.where(labels == 1)][:y]
print(labels_2.shape)
labels_3 = labels[np.where(labels == 2)][:y]
print(labels_3.shape)
labels_4 = labels[np.where(labels == 3)][:y]
print(labels_4.shape)
labels_5 = labels[np.where(labels == 4)][:y]
print(labels_5.shape)


l = [labels_1, labels_2, labels_3, labels_4, labels_5]
labels = l[0]
for i in l[1:]:
    labels = np.concatenate([labels, i], axis=0)
print(labels.shape)
print(pd.Series(labels).value_counts())


# replacing the initial labels with 0 : crewmate and 1 : imposter
labels = pd.Series(labels).replace(0, -1)
labels = pd.Series(labels).replace(0, 1)
labels = pd.Series(labels).replace(1, 1)
labels = pd.Series(labels).replace(2, 1)
labels = pd.Series(labels).replace(3, 1)
labels = pd.Series(labels).replace(4, 1)
labels = pd.Series(labels).replace(-1, 0)

labels = np.array(labels)

np.save("data.npy", data)
np.save("labels.npy", labels)

# we will use this data in susi som script 

# from IPython.display import FileLinks
# FileLinks('.')

"""* **SUSi SOM**"""
